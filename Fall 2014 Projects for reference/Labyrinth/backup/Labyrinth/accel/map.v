//	map.v - World map logic for rojobot systems
//	
//	Copyright Roy Kravitz, 2006-2014, 2015
//
//	Created By:			Roy Kravitz
//	Last Modified:		11-Oct-2014 (RK)
//	
//	Revision History:
//	-----------------
//	Sep-2006		RK		Created this module
//	Jan-2006		RK		Changed map addressing to 128 x 128
//	Jan-2006		RK		Modified to use world map generated by CoreGen
//	Oct-2009		RK		Minor changes (comments only) for conversion to ECE 510
//	Oct-2011		RK		Minor changes (comments only)
//	Oct-2012		RK		Modified for kcpsm6 and Nexys 3
//	Jan-2014		RK		Cleaned up the formatting.  No functional changes	
//	Oct-2014		RK		Checked for Nexys4 and Vivado compatibility.  No changes		
//	
//	Description
//	-----------
//	This module implements the world map for the rojobot to exist in.  It
//	interfaces with the world simulator (implemented in a Picoblaze) and with
//	the VGA logic.
//	
//	The interface to the BOTSIM is through several registers 
//	(produced in world_if.v) that interrogate the map logic (in this module)
//	to find the type of location that Rojobot is on and the sensor readings
//	for the locations around the Rojobot.
//	
//	The interface to the video logic is simpler in that it only returns
//	the value of the location being displayed to the video logic.
//	
//	The major component of map.v is a 16K dual port RAM implemented in two
//	block RAMS.  This RAM is addressed by the simulator
//	with a 7-bit column address and a 7-bit row address.
//
// 	The world map is 128 (cols) by 128 (rows)with each location on the world map
// 	roughly convering 16 (4 x 4) pixels on the 640 x 480 display.  Each location is represented by
// 	two pixels with the following meaning:
//		00 - "ground"   	This is just the background.  No obstruction, no black line
//		01 - "black line"	This location has a black line painted on it
//		10 - "obstruction"	There is an obstruction (like a wall) at this location
//		11-  "reserved"		This is nothing yet so should be treated like "ground"
//
//////////

module map 
#(
    parameter PORT_A_ENABLE = 'b1,
    parameter PORT_B_ENABLE = 'b1,
    parameter integer MAP_WIDTH = 320,
    parameter integer MAP_HEIGHT = 240
)
(

	// interface to external world emulator
	input 		[9:0]	a_col_addr,	// column address of world map location
	input 		[9:0]	a_row_addr,	// row address of world map location	
	output		[7:0]	a_out,	// map value for location [row_addr, col_addr]

		// interface to the video logic
	input 		[9:0]	b_col_addr,		// video logic column address
				[9:0]	b_row_addr,		// video logic row address
	output		[7:0]	b_out,	// pixel (location) value

	// interface to the system
	input				clk,			// system clock
						reset			// system reset
);

//localparam
//	GND		= 8'b00,	// ground - no obstruction, no black line
//	BLKL	= 8'b01,	// black line
//	OBSTR	= 8'b10,	// obstruction - either border wall or barrier
//	RSVD	= 8'b00;	// reserved - treat as "ground" for now
		
		
reg 	[16:0] 	a_mem_addr, b_mem_addr; 
wire    [9:0]   a_col_half, a_row_half, b_col_half, b_row_half;

assign  		a_col_half = a_col_addr >> 1;
assign  		a_row_half = a_row_addr >> 1;
assign  		b_col_half = b_col_addr >> 1;
assign  		b_row_half = b_row_addr >> 1;							
										
    `define NULL_ADDR 17'd76801

// implement the address latches
always @ (*) begin	
	if ( reset) begin
		a_mem_addr <= 17'b0;
		b_mem_addr <= 17'b0;
	end
	else begin
		if (a_row_half[7:0] <= MAP_HEIGHT && a_col_half[8:0] <= MAP_WIDTH) begin
			a_mem_addr <= a_row_half[7:0]*MAP_WIDTH + a_col_half[8:0]; 
			end
		else begin
			a_mem_addr <= `NULL_ADDR;
			end
				
        if (b_row_half[7:0] <= MAP_HEIGHT && b_col_half[8:0] <= MAP_WIDTH) begin
            b_mem_addr <= b_row_half[7:0]*MAP_WIDTH + b_col_half[8:0];
            end
        else begin
            b_mem_addr <= `NULL_ADDR;
            end	
	end
end

// Instantiate the world map ROM (generated by Xilinx Core Gnerator
maze_memory maze (
	.clka(clk),
	.addra(a_mem_addr),
	.douta(a_out),
	.ena(PORT_A_ENABLE),
	.clkb(clk),
	.addrb(b_mem_addr),
	.doutb(b_out),
	.enb(PORT_B_ENABLE)
);	
	
endmodule